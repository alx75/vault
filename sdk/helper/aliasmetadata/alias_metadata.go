package aliasmetadata

import (
	"fmt"

	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/helper/strutil"
	"github.com/hashicorp/vault/sdk/logical"
)

type Fields struct {
	// Default is a list of the default fields that should
	// be included if a user sends "default" in their list
	// of desired fields. These fields should all have a
	// low rate of change because each change can incur a
	// write to storage.
	Default []string

	// AvailableToAdd is a list of fields not included by
	// default, that the user may include.
	AvailableToAdd []string
}

const FieldName = "alias_metadata"

func Schema(fields *Fields) *framework.FieldSchema {
	return &framework.FieldSchema{
		Type:        framework.TypeCommaStringSlice,
		Description: description(fields),
		DisplayAttrs: &framework.DisplayAttributes{
			Name:  FieldName,
			Value: "default,field1,field2",
		},
		Default: []string{"default"},
	}
}

func NewHandler(fields *Fields) Handler {
	return &handler{
		fields: fields,
	}
}

type Handler interface {
	GetAliasMetadata() []string
	ParseAliasMetadata(data *framework.FieldData)
	PopulateDesiredAliasMetadata(auth *logical.Auth, fieldValues map[string]string)
}

type handler struct {
	// AliasMetadata is an explicit list of all the fields
	// that are being added to alias metadata.
	AliasMetadata []string `json:"alias_metadata"`

	// fields is a list of the configured default and available
	// fields.
	fields *Fields
}

func (h *handler) GetAliasMetadata() []string {
	return h.AliasMetadata
}

// TODO test when nothing is sent, vs "default", vs "default,field1", by hand externally
func (h *handler) ParseAliasMetadata(data *framework.FieldData) {
	uniqueFields := make(map[string]bool)
	aliasMetadata := data.Get(FieldName).([]string)
	for _, field := range aliasMetadata {
		if field == "default" {
			for _, dfltField := range h.fields.Default {
				uniqueFields[dfltField] = true
			}
		}
		uniqueFields[field] = true
	}
	h.AliasMetadata = make([]string, len(uniqueFields))
	i := 0
	for fieldName := range uniqueFields {
		h.AliasMetadata[i] = fieldName
		i++
	}
}

func (h *handler) PopulateDesiredAliasMetadata(auth *logical.Auth, fieldValues map[string]string) {
	for fieldName, fieldValue := range fieldValues {
		if strutil.StrListContains(h.AliasMetadata, fieldName) {
			auth.Alias.Metadata[fieldName] = fieldValue
		}
	}
}

func description(fields *Fields) string {
	desc := "The metadata to include on the aliases generated by this plugin."
	if len(fields.Default) > 0 {
		desc += fmt.Sprintf(` '%s' are included when set to "default".`, fields.Default)
	}
	if len(fields.AvailableToAdd) > 0 {
		desc += fmt.Sprintf(" '%s' are available to add.", fields.AvailableToAdd)
	}
	desc += ` Not editing this field means the "default" fields are included.` +
		` Explicitly setting this field to empty overrides the "default" and means no alias metadata will be included.` +
		` Add fields by sending, "default,field1,field2".` +
		` We advise only including fields that change rarely because each change triggers a storage write.`
	return desc
}
